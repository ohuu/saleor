# Generated by Django 3.2.6 on 2021-11-30 08:19

import re

import django.contrib.postgres.indexes
from django.db import migrations, models
from django.db.models import prefetch_related_objects
from django.utils.html import strip_tags
from urllib3.util import parse_url

BATCH_SIZE = 10000
PRODUCT_SEARCH_FIELDS = ["name", "description_plaintext"]
BLACKLISTED_URL_SCHEMES = ("javascript",)
HYPERLINK_TAG_WITH_URL_PATTERN = r"(.*?<a\s+href=\\?\")(\w+://\S+[^\\])(\\?\">)"


def set_search_document(apps, schema_editor):
    Product = apps.get_model("product", "Product")

    products = []
    for product in Product.objects.iterator():
        product.search_document = prepare_product_search_document_value(product)
        products.append(product)

    Product.objects.bulk_update(products, ["search_document"], batch_size=BATCH_SIZE)


def prepare_product_search_document_value(product):
    prefetch_related_objects(
        [product],
        "variants__attributes__values",
        "variants__attributes__assignment__attribute",
        "attributes__values",
        "attributes__assignment__attribute",
    )
    search_document = generate_product_fields_search_document_value(product)
    search_document += generate_attributes_search_document_value(
        product.attributes.all()
    )
    search_document += generate_variants_search_document_value(product)

    return search_document.lower()


def generate_product_fields_search_document_value(product):
    value = "\n".join(
        [
            getattr(product, field)
            for field in PRODUCT_SEARCH_FIELDS
            if getattr(product, field)
        ]
    )
    if value:
        value += "\n"
    return value.lower()


def generate_variants_search_document_value(product):
    variants = product.variants.all()
    variants_data = "\n".join([variant.sku for variant in variants if variant.sku])
    if variants_data:
        variants_data += "\n"

    for variant in variants:
        variant_attribute_data = generate_attributes_search_document_value(
            variant.attributes.all()
        )
        if variant_attribute_data:
            variants_data += variant_attribute_data

    return variants_data.lower()


def generate_attributes_search_document_value(assigned_attributes):
    """Prepare `search_document` value for assigned attributes.

    Method should received assigned attributes with prefetched `values`
    and `assignment__attribute`.
    """
    attribute_data = ""
    for assigned_attribute in assigned_attributes:
        attribute = assigned_attribute.assignment.attribute

        input_type = attribute.input_type
        values = assigned_attribute.values.all()
        values_list = []
        if input_type in ["dropdown", "multiselect"]:
            values_list = [value.name for value in values]
        elif input_type == "rich-text":
            values_list = [clean_editor_js(value.rich_text) for value in values]
        elif input_type == "numeric":
            unit = attribute.unit
            values_list = [value.name + unit for value in values]
        elif input_type in ["date", "date-time"]:
            values_list = [value.date_time.isoformat() for value in values]

        if values_list:
            values_data = "\n".join(values_list)
            attribute_data += values_data + "\n"
    return attribute_data.lower()


def clean_editor_js(definitions):
    if definitions is None:
        return ""

    blocks = definitions.get("blocks")

    if not blocks or not isinstance(blocks, list):
        return ""

    plain_text_list = []

    for block in blocks:
        block_type = block["type"]
        data = block.get("data")
        if not data or not isinstance(data, dict):
            continue

        if block_type == "list":
            for item in block["data"]["items"]:
                if not item:
                    continue
                new_text = clean_text_data(item)
                plain_text_list.append(strip_tags(new_text))

        else:
            text = block["data"].get("text")
            if not text:
                continue
            new_text = clean_text_data(text)
            plain_text_list.append(strip_tags(new_text))

    return " ".join(plain_text_list)


def clean_text_data(text: str):
    if not text:
        return

    end_of_match = 0
    new_text = ""
    for match in re.finditer(HYPERLINK_TAG_WITH_URL_PATTERN, text):
        original_url = match.group(2)
        original_url.strip()

        url = parse_url(original_url)
        new_url = url.url
        if url.scheme in BLACKLISTED_URL_SCHEMES:
            new_url = "#invalid"

        new_text += match.group(1) + new_url + match.group(3)
        end_of_match = match.end()

    if end_of_match:
        new_text += text[end_of_match:]

    return new_text if new_text else text


class Migration(migrations.Migration):

    dependencies = [
        ("product", "0153_merge_20211006_0910"),
    ]

    operations = [
        migrations.AddField(
            model_name="product",
            name="search_document",
            field=models.TextField(blank=True, default=""),
        ),
        migrations.RunPython(set_search_document, migrations.RunPython.noop),
        migrations.AddIndex(
            model_name="product",
            index=django.contrib.postgres.indexes.GinIndex(
                fields=["search_document"],
                name="product_search_gin",
                opclasses=["gin_trgm_ops"],
            ),
        ),
        migrations.RemoveIndex(
            model_name="product",
            name="product_pro_search__e78047_gin",
        ),
        migrations.RemoveField(
            model_name="product",
            name="search_vector",
        ),
        migrations.RunSQL(
            """
            DROP TRIGGER IF EXISTS title_vector_update
            ON product_product
        """
        ),
        migrations.RunSQL(
            """
            DROP TRIGGER IF EXISTS tsvectorupdate
            ON product_product
        """
        ),
    ]
